documentation
v0.3
pyren - a batch renamer

pyren is a command line batch renamer written in python. pyren uses 
unix style pattern matching to look for files and uses a number of 
optional arguments to be applied to the set of files found.
files are placed into a set with glob, then renamed based on 
the optional args. 

1. implementation detail

1.1 pyren argument parsing
argparse is the module used to implement argument parsing from the
command line. the following is enabled:
-   epilog: prints version after help
-   prefix_chars: only accept dashes for optional arguments
-   fromfile_prefix_char: accept arguments from file

arguments:
dir: specifies the file pattern to search for. expands into directories
     e.g. testdir/ -> testdir/*

optional arguments:
spaces:     removes all whitespaces
separator:  replaces specified separator with different separator
case:       changes case of file. upper/lower/swap/capitalise word
bracs:      replace brackets with round or square. exclusive with bracr
bracr:      remove brackets and text. exclusive with bracs
append:     append text to file
prepend:    prepend text to file
enumerate:  use numbers and append
extension:  change extension of file
regex:      use regex to replace
quiet:      suppress output. only shows what will be renamed and prompt
verbose:    show what args were invoked
version:    show version


1.2 file and pattern matching
unix style pattern matching can be implemented using a number of
different modules.

glob.iglob()
-   simplest with the most support
-   treats hidden files as special
-   supports recursion, not that it should ever be used

pathlib
-   full blown directory management
-   has its own implementation of glob
-   hashable
-   complex

at the moment we're using glob. pathlib is an option if we want less 
imports.


1.3.1 file renaming filters
filters have an order used to preserve intent of the user. the 
general idea is that we want to change/remove before adding 
characters. it wouldn't make sense to change things that the user 
wants to add.

low priority:
-   spaces
-   separator
-   bracket remove (exclusive group)
-   bracket style  (exclusive group)
-   case

normal priority:
-   append
-   prepend

high priority
-   extension (only applies to extension)
-   enumerate
-   regex
-   str.strip (always applied to basename and ext)


1.3.2 filter implementation
filters are implemented as lambda expressions in a list. the
exception to this is high priority filters which are applied
external to the list of filters.
filenames are passed in from file pattern matching and split into
directory, basename and ext. each basename is run against the list 
of filters. final processing occurs with high priority filters. 
a list of supported filters can be found above (1.3.1).

the resulting filename is then recombined and processed to determine
if it is safe to rename.


1.4.1 processing rename information
if we rename a file to an existing filename the existing file will be 
overwritten. this is undesired behaviour so we need to ensure that it 
doesn't happen.

there are three conflicts that can occur:
-   two files are trying to rename itself to the same name
-   a file tries to rename itself to a file that won't be renamed
-   a file tries to rename itself to a file that will be renamed

note: the third conflict is a potential cycle (see 1.4.3)


1.4.1.1 conflict resolution
checking for a cycle is expensive and complicated. for that reason,
we only consider conflict checking for the first two cases above and
handle cycles with another method.

after filtering filenames, we categorise them into a nested dict
rentable = {
    'renames': { 
        # dest: src 
    },
    'conflicts': {
        # dest: [srcs]
    }
}

the renames field contains dest to src mappings. these are the files 
that can be renamed safely. using the sorted method, we can create a 
queue of (src, dest) files to rename.

the conflicts field contains dest to a list of srcs. the list of srcs 
are all in conflict over the filename dest.
for convenience we also place files that were found but unchanged by 
filters into conflicts. 
the following is used to distinguish the conflicts:
if length(dest) == 1, no filters applied
otherwise, file conflict over multiple files

the following applies:
for every src, dest
if dest is in conflict, then add src into conflicts[dest]
if dest is in renames, then there is a conflict, invalidate all dest
in rentable and add to conflicts[dest]
otherwise
    if src == dest, no filters applied, move to conflicts
    if src != dest, filters applied
        if dest exists and not in fileset, add to conflicts[dest]
        otherwise, add src to renames[dest]

note: a file not found by the file pattern will not be renamed, hence why
it is immediately invalid. if a file exists and is in fileset, then we 
haven't encountered it yet and can be handled by our cases later.

example
dir
    fileA   -> filea
    fileB   -> filea (conflict with filea)
    fileC   -> fileC
    fileD   -> fileC (conflict with fileC, unresolvable)


1.4.1.2 cycle resolution
cycles happen when each file wants to be renamed to the next.
dir
    filea -> fileb (cycle)
    fileb -> filec   ...
    filec -> filed   ...
    diled -> filea (cycle)
    filex -> filey (conflict with filey, resolvable)
    filey -> filez

filex -> filey will cause an overwrite. however, it is possible to delay
filex and rename filey first. this way, the conflict resolves itself.
however, in the case of filea, fileb, filec and filed a cycle will be
formed and cannot be resolved.
the best way to resolve this is to use two pass renaming.
create a random sequence whenever we get conflicts like this.
dir:
    filea           -> fileb (conflict, remove and get random sequence)
    filea           -> filea_1230
    fileb           -> filec (conflict)
    filec           -> filed (conflict)
    filed           -> filea (no conflict, if filea -> filea_1230)
    filea_1230      -> fileb

in this case, filea - filed is a cycle, so we have to use two pass for
every conflict we find.

for simplicity we generate numbers instead of random strings. the idea
is the same as the windows os system. we use a number and incase it in
brackets. if the file already exists, then we continue generating upwards.


planned updates
v0.3
-   generate rentable in renamer
-   use str.title over string.capwords
-   use exclusive group for quiet and verbose, bracs and bracr
-   use set and iglob to store files
-   improve display for rentable
-   implement conflict checking
-   generate random names for cycle resolution 
-   implement renaming
-   general bugfixes

v0.3.1
-   more verbose display
-   any bug fixes/code cleanup

v0.4
-   implement regex based filters
-   implement high priority filters
-   implement complex enumerate filter

v0.4.1
-   introduce more filters
-   any bug fixes/code cleanup


changelog:
25/07/2018
-   updated documentation to include planned updates
-   updated to reflect current code